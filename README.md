# Homework
## 88. 合并两个有序数组  
### 方法1 题解  
主要思路：多用一个新的数组来放排序后的结果，然后将新数组赋值给nums1数组  
主体的流程处理如下：  
1.从下标0开始比较nums1,nums2中的元素，哪个元素小放在新数组nums3中  
2.当其中一个数组遍历完之后，另一个数组剩下的元素全都复制到新数组中  
3.最后将新数组复制到nums1数组，完成。  
时间复杂度：O(N)，空间复杂度O(N)，因为使用了一个多余的数组，数组的长度即为空间复杂度  
需要注意的点：判断好数组越界问题，一定要在写完后，手动模拟下过程  
### 方法2 题解  
主要思路：结合题目的特点，nums1后面会有多余的空间，不用害怕被覆盖，因此可以考虑从后往前覆盖，只是需要存储更大的值（适用于更苛刻的要求，不让开辟新空间）  
主题处理流程和解法1类似  
时间复杂度:O(N)，空间复杂度O(1)  
PS：  
a) 从leetcode的提交结果来看，两者使用的内存相差不大  
b) 有个疑惑，在其中一个数组遍历完之后，临界条件的处理时，我是根据实际情况模拟来得出具体的下标应该如何根据现有的双指针（i,j）来得到，有没有更通用的方法来做呢？  
  
## 26. 删除有序数组中的重复项  
### 题解  
主要思路：弄清楚想要的数据是什么，这类问题都可以采用同一种想法。这一道题是重复的数据不要，因此只需要遍历数组找到和之前不同的数据，然后替换原有的数据即可。  
主体流程如下：  
1.因为第一个元素不管重复与否，都是要的，所以我们的被替换的元素下标从1开始（即第二个元素）  
2.遍历数组，找到和前一个元素不相同的元素，将这个元素替换下标为j的元素  
3.因为j已经被替换，是非重复的元素，j需要移动一位  
数组问题始终要注意数组下标是否会出现越界情况  
  
## 283. 移动零   
### 题解  
主要思路：和删除重复项是一样的解法，将非零数往前移动，然后剩下的位置用0覆盖即可。  
主体流程：  
1.因为第一个元素可能为0，也可能不为0，所以是否覆盖不确定，因此我们的额外指针j从0开始  
2.遍历数组，判断每个元素是否为0，如果为0，则覆盖下标为j的元素，j++，不为0就继续移动，j不变  
3.将所有的非0数移动完之后，开始将后续的所有元素替换为0即可  
## 206. 反转链表  
### 题解  
链表我比较头疼的是在于指针的移动，改变以及头节点的问题，回顾看了下李老师的PPT以及问了下群里的小伙伴，算是对头节点这块比之前理解的透彻了点。
头结点就是第一个节点，值就是链表的第一个值，指针Next指向的就是下一个节点，因此在循环遍历链表的时候，需要使用的是head != null，因为head就是当前的节点，直到head指向Null，代表链表遍历结束。  
链表中的多指针，可以理解为这些指向节点的指针的改变会影响到节点next指针的改变，因此在处理的时候需要格外小心。
主要思路：链表逆转和数组逆转不同的是，在于处理各个节点的指针是要额外小心，同时注意这里要处理的边数是n条边，而不是n-1条。  
至于为什么需要preNode节点，是因为在head指针移到下一个节点的时候，就失去了前一个节点的寻找方法，如果不保存的话，前一个节点的边就无法处理。  
而tail节点需要指向的是逆转后的链表的头部，最后返回tail就好了，因为head,preNode节点最终都指向了null，返回的话会出错，一开始我自己没有注意这个点，提交的时候就有问题了。  
主体流程：  
1.初始时tail指针指向null，因为要考虑到处理第一个节点时，next指针要指向null，随后tail指针再移动就好了，preNode节点要保存前一个节点的信息，因此初始时指向head即可。  
2.遍历链表，head先向前移动，指向第二个节点，此时preNode指向第一个节点，需要处理第一个节点的next指针，指向Null,也就是tail，这样就把翻转后的链表尾部给处理好了。  
3.然后tail指针指向第一个节点，preNode指向第二个节点，为下一轮循环遍历做好准备，依次按照上面的过程来处理，直到head指针指向null结束遍历，此时链表已经成功反转。  
  
## 25. K 个一组翻转链表  
### 题解  
这道题是在反复观看了李老师的讲解回放之后，根据处理的思路写出来的，在逆转链表那一块，一开始也没有考虑到k=1,k=2时的处理，后面看了回放才注意到这里没有注意边界情况，应该需要在提交前多多测试才行  
主要思路：按照题目的要求，需要分若干组，每组最多有k个节点，因此我们需要先分组，然后在每组中进行逆转操作。  
在实际写代码和思考为什么这么写的时候，其实有一点要注意，在迭代写法时，一定是要先处理好前面的分组，然后再对下一组进行逆转，再处理边界情况，这样正确的思维方式才能写对代码，否则容易陷入到错误的思维循环当中。  
像链表的题目中运用道不少抽象思维的指针，譬如说我们要处理组和组之间关系的时候，要想找到上一组的末尾节点，应该怎么处理呢？  
我自己就会卡住很久不知道该怎么处理，把这道题学习完了之后，我的理解是，想要找到，就拿个指针指向就好，但是要注意指针一开始指向的位置，进行初始化，随后在迭代的过程中进行更新即可。  
具体的流程可以复习代码和写的注释。  

  
## 66. 加一 
### 题解    
主要思路：这道题的解法比较简单，只需要在数组的末尾加1，然后判断进位情况，如果数组的下标为0的数位为10，那代表原数组不够用，需要新建一个数组，将进位后的数整体移动过去即可。  
数组的遍历比较方便，可以通过下标直接来遍历即可。  
主要流程：  
1.对于数组最后一位数+1；  
2.判断是否需要进位，从最后一位开始往前遍历，若是出现数位=10的情况，就需要模拟进位情况；  
3.如果第0号元素小于10，直接返回该数组即可，若第0号元素等于10，发生进位，需要新建一个数组来承载新的结果，遍历数组进行复制即可。  
